{"version":3,"sources":["components/Playable.js","components/Grid.js","logic/GameLogic.js","components/App.js","index.js"],"names":["React","memo","gridInfo","handlePress","gameOver","useContext","GameOverContext","style","width","height","backgroundColor","isInWin","border","borderRadius","margin","alignItems","justifyContent","cursor","onClick","value","fontSize","alignSelf","textAlign","color","grid","playerActivity","formattedGrid","map","row","rowIndex","playable","playableIndex","key","gridNumber","display","flexWrap","flexDirection","position","bottom","initializeGrid","outerGrid","currentGrid","innerGrid","checkForWin","winStatus","win","winner","inWin","draw","squareIsAvailable","forEach","square","squareIndex","minimax","turn","depth","alpha","beta","maximizingPlayer","newTurn","gridCopy","bestScore","Infinity","rowCounter","columnCounter","score","Math","max","min","createContext","useState","setGrid","setTurn","ai","human","toPlay","setToPlay","setGameOver","setAi","setDepth","useEffect","positionIndex","move","column","previousTurn","Provider","className","marginBottom","marginTop","marginRight","onChange","event","target","newGrid","handleUserClick","restart","rootNode","document","querySelector","ReactDOM","render"],"mappings":"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","file":"static/js/main.a3d7ba5c.chunk.js","sourcesContent":["import React, {\r\n    useContext,\r\n} from 'react';\r\nimport {GameOverContext} from './App';\r\n\r\nconst Playable = ({gridInfo, handlePress}) => {\r\n\r\n    const gameOver = useContext(GameOverContext);\r\n    return(\r\n        <div\r\n        style={{\r\n            width: '30%',\r\n            height: '30%',\r\n            backgroundColor: gridInfo.isInWin ? '#18a300': '#b1b3b1',\r\n            border: 'none',\r\n            borderRadius: 5,\r\n            margin: 3,\r\n            alignItems: 'center',\r\n            justifyContent: 'center',\r\n            cursor: 'pointer',\r\n        }}\r\n        onClick={() => {\r\n            if(!gridInfo.value && !gameOver) handlePress(gridInfo);\r\n            // console.log(\"clicked\");\r\n        }}\r\n        >\r\n            <div\r\n            style={{\r\n                alignItems: 'center',\r\n                justifyContent: 'center',\r\n                fontSize: '80px',\r\n                alignSelf: 'center',\r\n                textAlign: 'center',\r\n                width: '100%',\r\n                height: '100%',\r\n                color: '#ffffff',\r\n            }}\r\n            >\r\n                    {gridInfo.value}\r\n            \r\n            </div>\r\n        </div>\r\n\r\n    );\r\n}\r\n\r\nexport default React.memo(Playable);","import React from 'react';\r\nimport Playable from './Playable';\r\n\r\nconst Grid = ({grid, playerActivity}) => {\r\n\r\n    const formattedGrid = grid.map(\r\n        (row, rowIndex) => {\r\n           return(\r\n                row.map(\r\n                    (playable, playableIndex) => {\r\n                        return(\r\n                            <Playable\r\n                             key={playable.gridNumber} \r\n                             gridInfo={playable}\r\n                             handlePress={playerActivity}                              \r\n                             />\r\n                        );\r\n                    }\r\n                )\r\n           );\r\n        }\r\n    );\r\n    return(\r\n        <>\r\n            <div\r\n            style={{\r\n                display: 'flex',\r\n                flexWrap: 'wrap',\r\n                flexDirection: 'row',\r\n                width: '100%',\r\n                height: '70%',\r\n                // border: '5px solid #000000',\r\n                position: 'relative',\r\n                bottom: '0',\r\n            }}\r\n            >\r\n                {formattedGrid}\r\n            </div>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default React.memo(Grid);","export const initializeGrid = () => {\r\n    let grid = [];\r\n    let gridNumber = 1;\r\n    for(let outerGrid = 0; outerGrid < 3; outerGrid++){\r\n        let currentGrid = [];\r\n        \r\n        for(let innerGrid = 0; innerGrid < 3; innerGrid++){\r\n            currentGrid = [...currentGrid, {\r\n                value: null,\r\n                isInWin: false,\r\n                gridNumber,\r\n            }]\r\n            gridNumber++;\r\n        }\r\n\r\n        grid = [...grid, currentGrid];\r\n    }\r\n\r\n    return grid;\r\n}\r\n\r\nexport const handleUserClick = (currentGrid, gridNumber, turn) => {\r\n    let gridCopy = currentGrid;\r\n    currentGrid.forEach(\r\n        (row, rowIndex) => {\r\n            row.forEach(\r\n                (square, squareIndex) => {\r\n                    if(gridNumber == square.gridNumber){\r\n                        gridCopy[rowIndex][squareIndex].value = turn\r\n                    }\r\n                }\r\n            )\r\n        }\r\n    );\r\n\r\n    return gridCopy;\r\n}\r\n\r\nexport const checkForWin = (currentGrid) => {\r\n    let winStatus = {\r\n        win: false,\r\n        winner: null,\r\n        inWin: [],\r\n        draw: false,\r\n    }\r\n\r\n    let grid = currentGrid;\r\n\r\n    //the following code will check for a win in all tic tac toe win scenario possibilities\r\n    //first row\r\n    if(grid[0][0].value && grid[0][1].value && grid[0][2].value \r\n        && grid[0][0].value === grid[0][1].value\r\n        && grid[0][1].value === grid[0][2].value){\r\n            winStatus.win = true;\r\n            winStatus.winner = grid[0][0].value;\r\n            winStatus.inWin = [\r\n            grid[0][0].gridNumber,\r\n            grid[0][1].gridNumber,\r\n            grid[0][2].gridNumber,\r\n            ];\r\n        }\r\n    \r\n    //second row\r\n    if(grid[1][0].value && grid[1][1].value && grid[1][2].value \r\n        && grid[1][0].value === grid[1][1].value\r\n        && grid[1][1].value === grid[1][2].value){\r\n            winStatus.win = true;\r\n            winStatus.winner = grid[1][0].value;\r\n            winStatus.inWin = [\r\n                grid[1][0].gridNumber,\r\n                grid[1][1].gridNumber,\r\n                grid[1][2].gridNumber,\r\n                ];\r\n        }\r\n\r\n    //third row\r\n    if(grid[2][0].value && grid[2][1].value && grid[2][2].value \r\n        && grid[2][0].value === grid[2][1].value\r\n        && grid[2][1].value === grid[2][2].value){\r\n            winStatus.win = true;\r\n            winStatus.winner = grid[2][0].value;\r\n            winStatus.inWin = [\r\n                grid[2][0].gridNumber,\r\n                grid[2][1].gridNumber,\r\n                grid[2][2].gridNumber,\r\n                ];\r\n        }\r\n\r\n    //first column\r\n    if(grid[0][0].value && grid[1][0].value && grid[2][0].value \r\n        && grid[0][0].value === grid[1][0].value\r\n        && grid[1][0].value === grid[2][0].value){\r\n            winStatus.win = true;\r\n            winStatus.winner = grid[0][0].value;\r\n            winStatus.inWin = [\r\n                grid[0][0].gridNumber,\r\n                grid[1][0].gridNumber,\r\n                grid[2][0].gridNumber,\r\n                ];\r\n        }\r\n\r\n    //second column\r\n    if(grid[0][1].value && grid[1][1].value && grid[2][1].value \r\n        && grid[0][1].value === grid[1][1].value\r\n        && grid[1][1].value === grid[2][1].value){\r\n            winStatus.win = true;\r\n            winStatus.winner = grid[0][1].value;\r\n            winStatus.inWin = [\r\n                grid[0][1].gridNumber,\r\n                grid[1][1].gridNumber,\r\n                grid[2][1].gridNumber,\r\n                ];\r\n        }\r\n\r\n    //third column\r\n    if(grid[0][2].value && grid[1][2].value && grid[2][2].value \r\n        && grid[0][2].value === grid[1][2].value\r\n        && grid[1][2].value === grid[2][2].value){\r\n            winStatus.win = true;\r\n            winStatus.winner = grid[0][2].value;\r\n            winStatus.inWin = [\r\n                grid[0][2].gridNumber,\r\n                grid[1][2].gridNumber,\r\n                grid[2][2].gridNumber,\r\n                ];\r\n        }\r\n\r\n    //first diagonal\r\n    if(grid[0][0].value && grid[1][1].value && grid[2][2].value \r\n        && grid[0][0].value === grid[1][1].value\r\n        && grid[1][1].value === grid[2][2].value){\r\n            winStatus.win = true;\r\n            winStatus.winner = grid[2][2].value;\r\n            winStatus.inWin = [\r\n                grid[0][0].gridNumber,\r\n                grid[1][1].gridNumber,\r\n                grid[2][2].gridNumber,\r\n                ];\r\n        }\r\n\r\n    //other diagonal\r\n    if(grid[0][2].value && grid[1][1].value && grid[2][0].value \r\n        && grid[0][2].value === grid[1][1].value\r\n        && grid[1][1].value === grid[2][0].value){\r\n            winStatus.win = true;\r\n            winStatus.winner = grid[2][0].value;\r\n            winStatus.inWin = [\r\n                grid[0][2].gridNumber,\r\n                grid[1][1].gridNumber,\r\n                grid[2][0].gridNumber,\r\n                ];\r\n        }\r\n\r\n    //check for a draw\r\n    if(!winStatus.win){\r\n        let squareIsAvailable = false;\r\n        grid.forEach(\r\n            (row, rowIndex) => {\r\n                row.forEach(\r\n                    (square, squareIndex) => {\r\n                        if(!square.value){\r\n                            squareIsAvailable = true;\r\n                        }\r\n                    }\r\n                )\r\n            }\r\n        );\r\n\r\n        if(!squareIsAvailable){\r\n            winStatus.draw = true;\r\n        }\r\n    }\r\n\r\n\r\n    return winStatus;\r\n}\r\n\r\nexport const minimax = (turn, grid, depth, alpha, beta, maximizingPlayer) => {\r\n    let winStatus = checkForWin(grid);\r\n    if(winStatus.win){\r\n        if(winStatus.winner === 'X') return 1;\r\n        if(winStatus.winner === 'O') return -1;\r\n    }\r\n    if(winStatus.draw) return 0;\r\n    if(depth === 0){\r\n        if(maximizingPlayer){\r\n            return -1;\r\n        }else{\r\n            return 1;\r\n        }\r\n    }\r\n\r\n    if(maximizingPlayer){\r\n        let newTurn;\r\n        if(turn === 'X'){\r\n            newTurn = 'O';\r\n        }else{\r\n            newTurn = 'X';\r\n        }\r\n        let gridCopy = grid;\r\n            //make a move\r\n            let bestScore = -Infinity;\r\n            for(let rowCounter = 0; rowCounter < 3; rowCounter++){ \r\n                for(let columnCounter = 0; columnCounter < 3; columnCounter++){\r\n                    if(!grid[rowCounter][columnCounter].value){\r\n                        gridCopy[rowCounter][columnCounter].value = 'X';\r\n                        let score = minimax(newTurn, gridCopy, depth - 1, alpha, beta, false);\r\n                        gridCopy[rowCounter][columnCounter].value = null;\r\n                        bestScore = Math.max(bestScore, score);\r\n                        alpha = Math.max(alpha, score);\r\n                    }\r\n                }\r\n                if(beta <= alpha){\r\n                    // console.log(\"prunning on X\");\r\n                    break;\r\n                }\r\n            }\r\n            return bestScore;\r\n    }else{\r\n        let newTurn;\r\n        if(turn === 'X'){\r\n            newTurn = 'O';\r\n        }else{\r\n            newTurn = 'X';\r\n        }\r\n        let gridCopy = grid;\r\n            //make a move\r\n            let bestScore = Infinity;\r\n            for(let rowCounter = 0; rowCounter < 3; rowCounter++){ \r\n                for(let columnCounter = 0; columnCounter < 3; columnCounter++){\r\n                    if(!grid[rowCounter][columnCounter].value){\r\n                        gridCopy[rowCounter][columnCounter].value = 'O';\r\n                        let score = minimax(newTurn, gridCopy, depth - 1, alpha, beta, true);\r\n                        gridCopy[rowCounter][columnCounter].value = null;\r\n                        bestScore = Math.min(bestScore, score);\r\n                        beta = Math.min(beta, score)\r\n                    }\r\n                }\r\n\r\n                if(beta <= alpha){\r\n                    // console.log(\"prunning on O\");\r\n                    break;\r\n                }\r\n            }\r\n            return bestScore;\r\n    }\r\n}","import React, {\r\n    useState,\r\n    useEffect,\r\n} from 'react';\r\nimport Grid from './Grid';\r\nimport { \r\n    initializeGrid,\r\n    handleUserClick,\r\n    checkForWin,\r\n    minimax,\r\n } from '../logic/GameLogic';\r\n\r\nexport const GameOverContext = React.createContext();\r\n\r\nconst App = () => {\r\n\r\n    const [grid, setGrid] = useState(initializeGrid);\r\n    const [turn, setTurn] = useState('X');\r\n    const [toPlay, setToPlay] = useState({\r\n        ai: true,\r\n        human: false,\r\n    });\r\n    const [gameOver, setGameOver] = useState(false);\r\n    const [ai, setAi] = useState(true);\r\n    const [depth, setDepth] = useState(Infinity);\r\n\r\n\r\n    //callbacks\r\n    //1.Callback when a tic tac toe square is clicked\r\n    const launchPlayerActivity = (gridInfo) => {\r\n        let newGrid = handleUserClick(grid, gridInfo.gridNumber, turn);\r\n        \r\n        setGrid(newGrid);\r\n        setTurn(\r\n            previousTurn => {\r\n              let newTurn;\r\n              if(previousTurn === 'X'){\r\n                newTurn = 'O';\r\n              }else{\r\n                newTurn = 'X';\r\n              }\r\n      \r\n              return newTurn;\r\n            }\r\n          );\r\n        \r\n        setAi(true);\r\n        //change to play\r\n        setToPlay({\r\n            ai: true,\r\n            human: false,\r\n        }); \r\n    }\r\n\r\n    //2.Callback when a player restarts\r\n    const restart = () => {\r\n        //the winner should always start\r\n        //if draw, the flow should continue\r\n\r\n        let winStatus = checkForWin(grid);\r\n        if(winStatus.win){\r\n            if(toPlay.human && !toPlay.ai){\r\n                setToPlay({\r\n                    ai: true,\r\n                    human: false\r\n                });\r\n                setAi(true);\r\n            }else if(toPlay.ai && !toPlay.human){\r\n                setToPlay({\r\n                 ai: false,\r\n                 human: true,\r\n                });\r\n                setAi(false);\r\n            }\r\n           if(winStatus.winner === 'X'){\r\n               setTurn('X');\r\n           }else{\r\n               setTurn('O');\r\n           }\r\n        }\r\n        setGrid(initializeGrid());\r\n        setGameOver(false);\r\n    }\r\n\r\n    //3.Callback when a player opts to play as X\r\n    const changePlayer = event => {\r\n        if(event.target.value === 'X'){\r\n            setTurn('X');\r\n            setToPlay({\r\n                ai: false,\r\n                human: true,\r\n            });\r\n            setAi(false);\r\n            setGrid(initializeGrid());\r\n            setGameOver(false);\r\n        }else{\r\n            setTurn('X');\r\n            setToPlay({\r\n                ai: true,\r\n                human: false,\r\n            });\r\n            setAi(true);\r\n            setGrid(initializeGrid());\r\n            setGameOver(false);\r\n        }\r\n    }\r\n\r\n    //4. Callback when a player reduces the search depth\r\n    const changeDepth = event => {\r\n        setDepth(event.target.value);\r\n        setGrid(initializeGrid());\r\n        setGameOver(false);\r\n    }\r\n\r\n    //side effects\r\n    //1. Whenever the turn changes, we need to check for win, or draw\r\n    useEffect(\r\n        () => {\r\n            //check if there's a winner\r\n            const winStatus = checkForWin(grid);\r\n            if(winStatus.win || winStatus.draw){\r\n                setGameOver(true);                \r\n                \r\n                if(winStatus.win && !winStatus.draw){\r\n                    let gridCopy = grid;\r\n                    grid.forEach(\r\n                        (row, rowIndex) => {\r\n                            row.forEach(\r\n                                (square, squareIndex) => {\r\n                                    winStatus.inWin.forEach(\r\n                                        (position, positionIndex) => {\r\n                                            if(position === square.gridNumber){\r\n                                                gridCopy[rowIndex][squareIndex].isInWin = true;\r\n                                            }\r\n                                        }\r\n                                    )\r\n                                }\r\n                            )\r\n                        }\r\n                    );\r\n                    setGrid(gridCopy);\r\n                }\r\n                \r\n            }\r\n        }, [turn]\r\n    );\r\n    //2. We need to use changes in ai to determine whether it's the computer's turn to play\r\n    useEffect(\r\n        () => {\r\n            //check whether it's the computer's turn to move\r\n            //if it is, use minimax to help the computer make the best move\r\n            if(!gameOver && ai){\r\n                if(toPlay.ai && !toPlay.human){\r\n                    let gridCopy = grid;\r\n                    //make a move\r\n                    //if the ai is always maximizing\r\n                    let bestScore\r\n                    if(turn === 'X'){\r\n                        bestScore = -Infinity;\r\n                    }else{\r\n                        bestScore = Infinity;\r\n                    }\r\n                    let move = {\r\n                        row: null,\r\n                        column: null,\r\n                    }\r\n                    if(turn === 'X'){\r\n                        for(let rowCounter = 0; rowCounter < 3; rowCounter++){ \r\n                            for(let columnCounter = 0; columnCounter < 3; columnCounter++){\r\n                                if(!grid[rowCounter][columnCounter].value){\r\n                                    gridCopy[rowCounter][columnCounter].value = turn;\r\n                                    let score = minimax(turn, gridCopy, depth, -Infinity, Infinity, false);\r\n                                    gridCopy[rowCounter][columnCounter].value = null;\r\n                                    if(score > bestScore) {\r\n                                        move.row = rowCounter;\r\n                                        move.column = columnCounter;\r\n                                    }\r\n                                    bestScore = Math.max(bestScore, score);\r\n                                }\r\n                            }\r\n                        }\r\n                    }else{\r\n                        for(let rowCounter = 0; rowCounter < 3; rowCounter++){ \r\n                            for(let columnCounter = 0; columnCounter < 3; columnCounter++){\r\n                                if(!grid[rowCounter][columnCounter].value){\r\n                                    gridCopy[rowCounter][columnCounter].value = turn;\r\n                                    let score = minimax(turn, gridCopy, depth, -Infinity, Infinity, true);\r\n                                    gridCopy[rowCounter][columnCounter].value = null;\r\n                                    if(score < bestScore) {\r\n                                        move.row = rowCounter;\r\n                                        move.column = columnCounter;\r\n                                    }\r\n                                    bestScore = Math.min(bestScore, score);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    const winStatus = checkForWin(grid);\r\n                    if(!winStatus.win && !winStatus.draw){\r\n                        gridCopy[move.row][move.column].value = turn;\r\n    \r\n                        //change to play\r\n                        setToPlay({\r\n                            ai: false,\r\n                            human: true,\r\n                        });\r\n        \r\n                        //change grid\r\n                        setGrid(gridCopy);\r\n        \r\n                        //change turn\r\n                        setTurn(\r\n                            previousTurn => {\r\n                            let newTurn;\r\n                            if(previousTurn === 'X'){\r\n                                newTurn = 'O';\r\n                            }else{\r\n                                newTurn = 'X';\r\n                            }\r\n                    \r\n                            return newTurn;\r\n                            }\r\n                        );\r\n                        \r\n                        setAi(false);\r\n                    }else{\r\n                        //change turn\r\n                        setTurn(\r\n                            previousTurn => {\r\n                            let newTurn;\r\n                            if(previousTurn === 'X'){\r\n                                newTurn = 'O';\r\n                            }else{\r\n                                newTurn = 'X';\r\n                            }\r\n                    \r\n                            return newTurn;\r\n                            }\r\n                        );\r\n                        \r\n                        setAi(false);\r\n                        //change to play\r\n                        setToPlay({\r\n                            ai: false,\r\n                            human: true,\r\n                        });\r\n        \r\n                    }\r\n                }\r\n            }\r\n        }, [ai]\r\n    );\r\n\r\n\r\n    return (\r\n        <>\r\n            <GameOverContext.Provider\r\n            value={gameOver}\r\n            >\r\n                <div\r\n                className=\"container\"\r\n                style={{\r\n                    width: '400px',\r\n                    height: '600px',\r\n                    border: '2px solid #000000',\r\n                    backgroundColor: '#383838',\r\n\r\n                }}\r\n                >\r\n                    <div\r\n                    style={{\r\n                        display: 'flex',\r\n                        flexDirection: 'row',\r\n                        width: '100%',\r\n                        marginBottom: '15%',\r\n                        marginTop: '2%',\r\n                    }}\r\n                    >\r\n                        <div\r\n                        style={{\r\n                            width: '40%',\r\n                            height: '7%',\r\n                            marginRight: '10%',\r\n                            display: 'flex',\r\n                            flexDirection: 'row',\r\n                            \r\n                        }}\r\n                        >\r\n                            <label\r\n                            style={{\r\n                                color: '#ffffff',\r\n                                marginRight: '3px',\r\n                            }}\r\n                            >Start As: </label>\r\n                            <select\r\n                            style={{\r\n                                width: '100%',\r\n                                height: '100%',\r\n                                border: 'none',\r\n                                borderRadius: '5px',\r\n                                backgroundColor: '#b1b3b1',\r\n                                color: '#ffffff',\r\n                            }}\r\n                            onChange={changePlayer}\r\n                            >\r\n                                <option value={'O'}>O</option>\r\n                                <option value={'X'}>X</option>\r\n                            </select>\r\n                        </div>\r\n                        <div\r\n                        style={{\r\n                            width: '40%',\r\n                            height: '7%',\r\n                            display: 'flex',\r\n                            flexDirection: 'row',\r\n                        }}\r\n                        >\r\n                            <label\r\n                            style={{\r\n                                color: '#ffffff',\r\n                                marginRight: '3px',\r\n                            }}\r\n                            >AI Level: </label>\r\n                            <select\r\n                            style={{\r\n                                width: '100%',\r\n                                height: '100%',\r\n                                border: 'none',\r\n                                borderRadius: '5px',\r\n                                backgroundColor: '#b1b3b1',\r\n                                color: '#ffffff',\r\n                            }}\r\n                            onChange={changeDepth}\r\n                            >\r\n                                <option value={Infinity}>Hard</option>\r\n                                <option value={1}>Easy</option>\r\n                            </select>\r\n                        </div>\r\n                    </div>\r\n                    <Grid\r\n                    grid={grid}\r\n                    playerActivity={toPlay.human ? launchPlayerActivity: () => {}}\r\n                    /> \r\n                    {\r\n                        gameOver && \r\n                        <button \r\n                        onClick={() => restart()}\r\n                        style={{\r\n                            width: '95%',\r\n                            height: '10%', \r\n                            backgroundColor: '#18a300',\r\n                            border: 'none',\r\n                            color: '#ffffff',\r\n                        }}\r\n                        >\r\n                            Restart\r\n                        </button>\r\n                    }\r\n                </div> \r\n            </GameOverContext.Provider>\r\n        </>\r\n    )\r\n}\r\n\r\nexport default React.memo(App);","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './components/App';\r\n\r\nconst rootNode = document.querySelector(\"#root\");\r\n\r\nReactDOM.render(\r\n    <App/>, rootNode\r\n);"],"sourceRoot":""}