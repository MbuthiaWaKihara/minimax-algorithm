{"version":3,"sources":["components/Playable.js","components/Grid.js","components/Notification.js","logic/GameLogic.js","components/App.js","index.js"],"names":["React","memo","gridInfo","handlePress","gameOver","useContext","GameOverContext","useState","isTextShown","setIsTextShown","effect","useSpring","opacity","config","duration","useEffect","value","style","width","height","backgroundColor","isInWin","border","borderRadius","margin","alignItems","justifyContent","cursor","onClick","div","fontSize","alignSelf","textAlign","color","grid","playerActivity","formattedGrid","map","row","rowIndex","playable","playableIndex","key","gridNumber","display","flexWrap","flexDirection","position","bottom","closeToast","winner","initializeGrid","outerGrid","currentGrid","innerGrid","checkForWin","winStatus","win","inWin","draw","squareIsAvailable","forEach","square","squareIndex","minimax","turn","depth","alpha","beta","maximizingPlayer","newTurn","gridCopy","bestScore","Infinity","rowCounter","columnCounter","score","Math","max","min","createContext","toast","configure","setGrid","setTurn","ai","human","toPlay","setToPlay","setGameOver","setAi","setDepth","positionIndex","move","column","previousTurn","Provider","className","marginBottom","marginTop","marginRight","onChange","event","target","newGrid","handleUserClick","restart","rootNode","document","querySelector","ReactDOM","render"],"mappings":"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","file":"static/js/main.e4a71194.chunk.js","sourcesContent":["import React, {\r\n    useContext,\r\n    useState, \r\n    useEffect,\r\n} from 'react';\r\nimport {GameOverContext} from './App';\r\nimport {useSpring, animated} from 'react-spring'\r\n\r\nconst Playable = ({gridInfo, handlePress}) => {\r\n\r\n    const gameOver = useContext(GameOverContext);\r\n    const [isTextShown, setIsTextShown] = useState(false);\r\n    const effect = useSpring({\r\n        opacity: isTextShown ? 1 : 0,\r\n        config: {\r\n            duration: 500,\r\n        }\r\n    });\r\n\r\n    useEffect(\r\n        () => {\r\n            if(gridInfo.value){\r\n                setIsTextShown(true);\r\n            }else{\r\n                setIsTextShown(false);\r\n            }\r\n        },[gridInfo.value]\r\n    );\r\n    return(\r\n        <div\r\n        style={{\r\n            width: '30%',\r\n            height: '30%',\r\n            backgroundColor: gridInfo.isInWin ? '#18a300': '#b1b3b1',\r\n            border: 'none',\r\n            borderRadius: 5,\r\n            margin: 3,\r\n            alignItems: 'center',\r\n            justifyContent: 'center',\r\n            cursor: 'pointer',\r\n        }}\r\n        onClick={() => {\r\n            if(!gridInfo.value && !gameOver) handlePress(gridInfo);\r\n            // console.log(\"clicked\");\r\n        }}\r\n        >\r\n            <animated.div\r\n            style={{\r\n                alignItems: 'center',\r\n                justifyContent: 'center',\r\n                fontSize: '80px',\r\n                alignSelf: 'center',\r\n                textAlign: 'center',\r\n                width: '100%',\r\n                height: '100%',\r\n                color: '#ffffff',\r\n                opacity: effect.opacity,\r\n            }}\r\n            >\r\n                    {gridInfo.value}\r\n            \r\n            </animated.div>\r\n        </div>\r\n\r\n    );\r\n}\r\n\r\nexport default React.memo(Playable);","import React from 'react';\r\nimport Playable from './Playable';\r\n\r\nconst Grid = ({grid, playerActivity}) => {\r\n\r\n    const formattedGrid = grid.map(\r\n        (row, rowIndex) => {\r\n           return(\r\n                row.map(\r\n                    (playable, playableIndex) => {\r\n                        return(\r\n                            <Playable\r\n                             key={playable.gridNumber} \r\n                             gridInfo={playable}\r\n                             handlePress={playerActivity}                              \r\n                             />\r\n                        );\r\n                    }\r\n                )\r\n           );\r\n        }\r\n    );\r\n    return(\r\n        <>\r\n            <div\r\n            style={{\r\n                display: 'flex',\r\n                flexWrap: 'wrap',\r\n                flexDirection: 'row',\r\n                width: '100%',\r\n                height: '70%',\r\n                // border: '5px solid #000000',\r\n                position: 'relative',\r\n                bottom: '0',\r\n            }}\r\n            >\r\n                {formattedGrid}\r\n            </div>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default React.memo(Grid);","import React from 'react'\r\n\r\nexport const Notification = ({ closeToast, winner}) => {\r\n    return (\r\n        <>\r\n            <div\r\n            style={{\r\n            }}\r\n            >\r\n                {`${winner} won!`}\r\n            </div>\r\n            <button\r\n            style={{\r\n                border: 'none',\r\n                backgroundColor: '#b0b0b0',\r\n                color: '#ffffff',\r\n                borderRadius: '20px',\r\n                width: '100%',\r\n                textAlign: 'center',\r\n\r\n            }}\r\n            >\r\n                OK\r\n            </button>\r\n        </>\r\n    )\r\n}\r\n\r\nexport default React.memo(Notification);\r\n","export const initializeGrid = () => {\r\n    let grid = [];\r\n    let gridNumber = 1;\r\n    for(let outerGrid = 0; outerGrid < 3; outerGrid++){\r\n        let currentGrid = [];\r\n        \r\n        for(let innerGrid = 0; innerGrid < 3; innerGrid++){\r\n            currentGrid = [...currentGrid, {\r\n                value: null,\r\n                isInWin: false,\r\n                gridNumber,\r\n            }]\r\n            gridNumber++;\r\n        }\r\n\r\n        grid = [...grid, currentGrid];\r\n    }\r\n\r\n    return grid;\r\n}\r\n\r\nexport const handleUserClick = (currentGrid, gridNumber, turn) => {\r\n    let gridCopy = currentGrid;\r\n    currentGrid.forEach(\r\n        (row, rowIndex) => {\r\n            row.forEach(\r\n                (square, squareIndex) => {\r\n                    if(gridNumber == square.gridNumber){\r\n                        gridCopy[rowIndex][squareIndex].value = turn\r\n                    }\r\n                }\r\n            )\r\n        }\r\n    );\r\n\r\n    return gridCopy;\r\n}\r\n\r\nexport const checkForWin = (currentGrid) => {\r\n    let winStatus = {\r\n        win: false,\r\n        winner: null,\r\n        inWin: [],\r\n        draw: false,\r\n    }\r\n\r\n    let grid = currentGrid;\r\n\r\n    //the following code will check for a win in all tic tac toe win scenario possibilities\r\n    //first row\r\n    if(grid[0][0].value && grid[0][1].value && grid[0][2].value \r\n        && grid[0][0].value === grid[0][1].value\r\n        && grid[0][1].value === grid[0][2].value){\r\n            winStatus.win = true;\r\n            winStatus.winner = grid[0][0].value;\r\n            winStatus.inWin = [\r\n            grid[0][0].gridNumber,\r\n            grid[0][1].gridNumber,\r\n            grid[0][2].gridNumber,\r\n            ];\r\n        }\r\n    \r\n    //second row\r\n    if(grid[1][0].value && grid[1][1].value && grid[1][2].value \r\n        && grid[1][0].value === grid[1][1].value\r\n        && grid[1][1].value === grid[1][2].value){\r\n            winStatus.win = true;\r\n            winStatus.winner = grid[1][0].value;\r\n            winStatus.inWin = [\r\n                grid[1][0].gridNumber,\r\n                grid[1][1].gridNumber,\r\n                grid[1][2].gridNumber,\r\n                ];\r\n        }\r\n\r\n    //third row\r\n    if(grid[2][0].value && grid[2][1].value && grid[2][2].value \r\n        && grid[2][0].value === grid[2][1].value\r\n        && grid[2][1].value === grid[2][2].value){\r\n            winStatus.win = true;\r\n            winStatus.winner = grid[2][0].value;\r\n            winStatus.inWin = [\r\n                grid[2][0].gridNumber,\r\n                grid[2][1].gridNumber,\r\n                grid[2][2].gridNumber,\r\n                ];\r\n        }\r\n\r\n    //first column\r\n    if(grid[0][0].value && grid[1][0].value && grid[2][0].value \r\n        && grid[0][0].value === grid[1][0].value\r\n        && grid[1][0].value === grid[2][0].value){\r\n            winStatus.win = true;\r\n            winStatus.winner = grid[0][0].value;\r\n            winStatus.inWin = [\r\n                grid[0][0].gridNumber,\r\n                grid[1][0].gridNumber,\r\n                grid[2][0].gridNumber,\r\n                ];\r\n        }\r\n\r\n    //second column\r\n    if(grid[0][1].value && grid[1][1].value && grid[2][1].value \r\n        && grid[0][1].value === grid[1][1].value\r\n        && grid[1][1].value === grid[2][1].value){\r\n            winStatus.win = true;\r\n            winStatus.winner = grid[0][1].value;\r\n            winStatus.inWin = [\r\n                grid[0][1].gridNumber,\r\n                grid[1][1].gridNumber,\r\n                grid[2][1].gridNumber,\r\n                ];\r\n        }\r\n\r\n    //third column\r\n    if(grid[0][2].value && grid[1][2].value && grid[2][2].value \r\n        && grid[0][2].value === grid[1][2].value\r\n        && grid[1][2].value === grid[2][2].value){\r\n            winStatus.win = true;\r\n            winStatus.winner = grid[0][2].value;\r\n            winStatus.inWin = [\r\n                grid[0][2].gridNumber,\r\n                grid[1][2].gridNumber,\r\n                grid[2][2].gridNumber,\r\n                ];\r\n        }\r\n\r\n    //first diagonal\r\n    if(grid[0][0].value && grid[1][1].value && grid[2][2].value \r\n        && grid[0][0].value === grid[1][1].value\r\n        && grid[1][1].value === grid[2][2].value){\r\n            winStatus.win = true;\r\n            winStatus.winner = grid[2][2].value;\r\n            winStatus.inWin = [\r\n                grid[0][0].gridNumber,\r\n                grid[1][1].gridNumber,\r\n                grid[2][2].gridNumber,\r\n                ];\r\n        }\r\n\r\n    //other diagonal\r\n    if(grid[0][2].value && grid[1][1].value && grid[2][0].value \r\n        && grid[0][2].value === grid[1][1].value\r\n        && grid[1][1].value === grid[2][0].value){\r\n            winStatus.win = true;\r\n            winStatus.winner = grid[2][0].value;\r\n            winStatus.inWin = [\r\n                grid[0][2].gridNumber,\r\n                grid[1][1].gridNumber,\r\n                grid[2][0].gridNumber,\r\n                ];\r\n        }\r\n\r\n    //check for a draw\r\n    if(!winStatus.win){\r\n        let squareIsAvailable = false;\r\n        grid.forEach(\r\n            (row, rowIndex) => {\r\n                row.forEach(\r\n                    (square, squareIndex) => {\r\n                        if(!square.value){\r\n                            squareIsAvailable = true;\r\n                        }\r\n                    }\r\n                )\r\n            }\r\n        );\r\n\r\n        if(!squareIsAvailable){\r\n            winStatus.draw = true;\r\n        }\r\n    }\r\n\r\n\r\n    return winStatus;\r\n}\r\n\r\nexport const minimax = (turn, grid, depth, alpha, beta, maximizingPlayer) => {\r\n    let winStatus = checkForWin(grid);\r\n    if(winStatus.win){\r\n        if(winStatus.winner === 'X') return 1;\r\n        if(winStatus.winner === 'O') return -1;\r\n    }\r\n    if(winStatus.draw) return 0;\r\n    if(depth === 0){\r\n        if(maximizingPlayer){\r\n            return -1;\r\n        }else{\r\n            return 1;\r\n        }\r\n    }\r\n\r\n    if(maximizingPlayer){\r\n        let newTurn;\r\n        if(turn === 'X'){\r\n            newTurn = 'O';\r\n        }else{\r\n            newTurn = 'X';\r\n        }\r\n        let gridCopy = grid;\r\n            //make a move\r\n            let bestScore = -Infinity;\r\n            for(let rowCounter = 0; rowCounter < 3; rowCounter++){ \r\n                for(let columnCounter = 0; columnCounter < 3; columnCounter++){\r\n                    if(!grid[rowCounter][columnCounter].value){\r\n                        gridCopy[rowCounter][columnCounter].value = 'X';\r\n                        let score = minimax(newTurn, gridCopy, depth - 1, alpha, beta, false);\r\n                        gridCopy[rowCounter][columnCounter].value = null;\r\n                        bestScore = Math.max(bestScore, score);\r\n                        alpha = Math.max(alpha, score);\r\n                    }\r\n                }\r\n                if(beta <= alpha){\r\n                    // console.log(\"prunning on X\");\r\n                    break;\r\n                }\r\n            }\r\n            return bestScore;\r\n    }else{\r\n        let newTurn;\r\n        if(turn === 'X'){\r\n            newTurn = 'O';\r\n        }else{\r\n            newTurn = 'X';\r\n        }\r\n        let gridCopy = grid;\r\n            //make a move\r\n            let bestScore = Infinity;\r\n            for(let rowCounter = 0; rowCounter < 3; rowCounter++){ \r\n                for(let columnCounter = 0; columnCounter < 3; columnCounter++){\r\n                    if(!grid[rowCounter][columnCounter].value){\r\n                        gridCopy[rowCounter][columnCounter].value = 'O';\r\n                        let score = minimax(newTurn, gridCopy, depth - 1, alpha, beta, true);\r\n                        gridCopy[rowCounter][columnCounter].value = null;\r\n                        bestScore = Math.min(bestScore, score);\r\n                        beta = Math.min(beta, score)\r\n                    }\r\n                }\r\n\r\n                if(beta <= alpha){\r\n                    // console.log(\"prunning on O\");\r\n                    break;\r\n                }\r\n            }\r\n            return bestScore;\r\n    }\r\n}","import React, {\r\n    useState,\r\n    useEffect,\r\n} from 'react';\r\nimport Grid from './Grid';\r\nimport Notification from './Notification';\r\nimport { \r\n    initializeGrid,\r\n    handleUserClick,\r\n    checkForWin,\r\n    minimax,\r\n } from '../logic/GameLogic';\r\n import { toast } from 'react-toastify';\r\n import 'react-toastify/dist/ReactToastify.css';\r\n\r\n\r\nexport const GameOverContext = React.createContext();\r\ntoast.configure();\r\n\r\nconst App = () => {\r\n\r\n    const [grid, setGrid] = useState(initializeGrid);\r\n    const [turn, setTurn] = useState('X');\r\n    const [toPlay, setToPlay] = useState({\r\n        ai: true,\r\n        human: false,\r\n    });\r\n    const [gameOver, setGameOver] = useState(false);\r\n    const [ai, setAi] = useState(true);\r\n    const [depth, setDepth] = useState(Infinity);\r\n\r\n\r\n    //callbacks\r\n    //1.Callback when a tic tac toe square is clicked\r\n    const launchPlayerActivity = (gridInfo) => {\r\n        let newGrid = handleUserClick(grid, gridInfo.gridNumber, turn);\r\n        \r\n        setGrid(newGrid);\r\n        setTurn(\r\n            previousTurn => {\r\n              let newTurn;\r\n              if(previousTurn === 'X'){\r\n                newTurn = 'O';\r\n              }else{\r\n                newTurn = 'X';\r\n              }\r\n      \r\n              return newTurn;\r\n            }\r\n          );\r\n        \r\n        setAi(true);\r\n        //change to play\r\n        setToPlay({\r\n            ai: true,\r\n            human: false,\r\n        }); \r\n    }\r\n\r\n    //2.Callback when a player restarts\r\n    const restart = () => {\r\n        //the winner should always start\r\n        //if draw, the flow should continue\r\n\r\n        let winStatus = checkForWin(grid);\r\n        if(winStatus.win){\r\n            if(toPlay.human && !toPlay.ai){\r\n                setToPlay({\r\n                    ai: true,\r\n                    human: false\r\n                });\r\n                setAi(true);\r\n            }else if(toPlay.ai && !toPlay.human){\r\n                setToPlay({\r\n                 ai: false,\r\n                 human: true,\r\n                });\r\n                setAi(false);\r\n            }\r\n           if(winStatus.winner === 'X'){\r\n               setTurn('X');\r\n           }else{\r\n               setTurn('O');\r\n           }\r\n        }\r\n        setGrid(initializeGrid());\r\n        setGameOver(false);\r\n    }\r\n\r\n    //3.Callback when a player opts to play as X\r\n    const changePlayer = event => {\r\n        if(event.target.value === 'X'){\r\n            setTurn('X');\r\n            setToPlay({\r\n                ai: false,\r\n                human: true,\r\n            });\r\n            setAi(false);\r\n            setGrid(initializeGrid());\r\n            setGameOver(false);\r\n        }else{\r\n            setTurn('X');\r\n            setToPlay({\r\n                ai: true,\r\n                human: false,\r\n            });\r\n            setAi(true);\r\n            setGrid(initializeGrid());\r\n            setGameOver(false);\r\n        }\r\n    }\r\n\r\n    //4. Callback when a player reduces the search depth\r\n    const changeDepth = event => {\r\n        setDepth(event.target.value);\r\n        setGrid(initializeGrid());\r\n        setGameOver(false);\r\n    }\r\n\r\n    //5. Callback to trigger notification when there's a winner\r\n    const notify = winner => {\r\n        toast(<Notification winner={winner} />, {\r\n            //config\r\n        })\r\n    }\r\n\r\n    //side effects\r\n    //1. Whenever the turn changes, we need to check for win, or draw\r\n    useEffect(\r\n        () => {\r\n            //check if there's a winner\r\n            const winStatus = checkForWin(grid);\r\n            if(winStatus.win || winStatus.draw){\r\n                setGameOver(true);                \r\n                \r\n                if(winStatus.win && !winStatus.draw){\r\n                    notify(winStatus.winner);\r\n                    let gridCopy = grid;\r\n                    grid.forEach(\r\n                        (row, rowIndex) => {\r\n                            row.forEach(\r\n                                (square, squareIndex) => {\r\n                                    winStatus.inWin.forEach(\r\n                                        (position, positionIndex) => {\r\n                                            if(position === square.gridNumber){\r\n                                                gridCopy[rowIndex][squareIndex].isInWin = true;\r\n                                            }\r\n                                        }\r\n                                    )\r\n                                }\r\n                            )\r\n                        }\r\n                    );\r\n                    setGrid(gridCopy);\r\n                }\r\n                \r\n            }\r\n        }, [turn]\r\n    );\r\n    //2. We need to use changes in ai to determine whether it's the computer's turn to play\r\n    useEffect(\r\n        () => {\r\n            //check whether it's the computer's turn to move\r\n            //if it is, use minimax to help the computer make the best move\r\n            if(!gameOver && ai){\r\n                if(toPlay.ai && !toPlay.human){\r\n                    let gridCopy = grid;\r\n                    //make a move\r\n                    //if the ai is always maximizing\r\n                    let bestScore\r\n                    if(turn === 'X'){\r\n                        bestScore = -Infinity;\r\n                    }else{\r\n                        bestScore = Infinity;\r\n                    }\r\n                    let move = {\r\n                        row: null,\r\n                        column: null,\r\n                    }\r\n                    if(turn === 'X'){\r\n                        for(let rowCounter = 0; rowCounter < 3; rowCounter++){ \r\n                            for(let columnCounter = 0; columnCounter < 3; columnCounter++){\r\n                                if(!grid[rowCounter][columnCounter].value){\r\n                                    gridCopy[rowCounter][columnCounter].value = turn;\r\n                                    let score = minimax(turn, gridCopy, depth, -Infinity, Infinity, false);\r\n                                    gridCopy[rowCounter][columnCounter].value = null;\r\n                                    if(score > bestScore) {\r\n                                        move.row = rowCounter;\r\n                                        move.column = columnCounter;\r\n                                    }\r\n                                    bestScore = Math.max(bestScore, score);\r\n                                }\r\n                            }\r\n                        }\r\n                    }else{\r\n                        for(let rowCounter = 0; rowCounter < 3; rowCounter++){ \r\n                            for(let columnCounter = 0; columnCounter < 3; columnCounter++){\r\n                                if(!grid[rowCounter][columnCounter].value){\r\n                                    gridCopy[rowCounter][columnCounter].value = turn;\r\n                                    let score = minimax(turn, gridCopy, depth, -Infinity, Infinity, true);\r\n                                    gridCopy[rowCounter][columnCounter].value = null;\r\n                                    if(score < bestScore) {\r\n                                        move.row = rowCounter;\r\n                                        move.column = columnCounter;\r\n                                    }\r\n                                    bestScore = Math.min(bestScore, score);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    const winStatus = checkForWin(grid);\r\n                    if(!winStatus.win && !winStatus.draw){\r\n                        gridCopy[move.row][move.column].value = turn;\r\n    \r\n                        //change to play\r\n                        setToPlay({\r\n                            ai: false,\r\n                            human: true,\r\n                        });\r\n        \r\n                        //change grid\r\n                        setGrid(gridCopy);\r\n        \r\n                        //change turn\r\n                        setTurn(\r\n                            previousTurn => {\r\n                            let newTurn;\r\n                            if(previousTurn === 'X'){\r\n                                newTurn = 'O';\r\n                            }else{\r\n                                newTurn = 'X';\r\n                            }\r\n                    \r\n                            return newTurn;\r\n                            }\r\n                        );\r\n                        \r\n                        setAi(false);\r\n                    }else{\r\n                        //change turn\r\n                        setTurn(\r\n                            previousTurn => {\r\n                            let newTurn;\r\n                            if(previousTurn === 'X'){\r\n                                newTurn = 'O';\r\n                            }else{\r\n                                newTurn = 'X';\r\n                            }\r\n                    \r\n                            return newTurn;\r\n                            }\r\n                        );\r\n                        \r\n                        setAi(false);\r\n                        //change to play\r\n                        setToPlay({\r\n                            ai: false,\r\n                            human: true,\r\n                        });\r\n        \r\n                    }\r\n                }\r\n            }\r\n        }, [ai]\r\n    );\r\n\r\n\r\n    return (\r\n        <>\r\n            <GameOverContext.Provider\r\n            value={gameOver}\r\n            >\r\n                <div\r\n                className=\"container\"\r\n                style={{\r\n                    width: '400px',\r\n                    height: '600px',\r\n                    border: '2px solid #000000',\r\n                    backgroundColor: '#383838',\r\n\r\n                }}\r\n                >\r\n                    <div\r\n                    style={{\r\n                        display: 'flex',\r\n                        flexDirection: 'row',\r\n                        width: '100%',\r\n                        marginBottom: '15%',\r\n                        marginTop: '2%',\r\n                    }}\r\n                    >\r\n                        <div\r\n                        style={{\r\n                            width: '40%',\r\n                            height: '7%',\r\n                            marginRight: '10%',\r\n                            display: 'flex',\r\n                            flexDirection: 'row',\r\n                            \r\n                        }}\r\n                        >\r\n                            <label\r\n                            style={{\r\n                                color: '#ffffff',\r\n                                marginRight: '3px',\r\n                            }}\r\n                            >Start As: </label>\r\n                            <select\r\n                            style={{\r\n                                width: '100%',\r\n                                height: '100%',\r\n                                border: 'none',\r\n                                borderRadius: '5px',\r\n                                backgroundColor: '#b1b3b1',\r\n                                color: '#ffffff',\r\n                            }}\r\n                            onChange={changePlayer}\r\n                            >\r\n                                <option value={'O'}>O</option>\r\n                                <option value={'X'}>X</option>\r\n                            </select>\r\n                        </div>\r\n                        <div\r\n                        style={{\r\n                            width: '40%',\r\n                            height: '7%',\r\n                            display: 'flex',\r\n                            flexDirection: 'row',\r\n                        }}\r\n                        >\r\n                            <label\r\n                            style={{\r\n                                color: '#ffffff',\r\n                                marginRight: '3px',\r\n                            }}\r\n                            >AI Level: </label>\r\n                            <select\r\n                            style={{\r\n                                width: '100%',\r\n                                height: '100%',\r\n                                border: 'none',\r\n                                borderRadius: '5px',\r\n                                backgroundColor: '#b1b3b1',\r\n                                color: '#ffffff',\r\n                            }}\r\n                            onChange={changeDepth}\r\n                            >\r\n                                <option value={Infinity}>Hard</option>\r\n                                <option value={1}>Easy</option>\r\n                            </select>\r\n                        </div>\r\n                    </div>\r\n                    <Grid\r\n                    grid={grid}\r\n                    playerActivity={toPlay.human ? launchPlayerActivity: () => {}}\r\n                    /> \r\n                    {\r\n                        gameOver && \r\n                        <button \r\n                        onClick={() => restart()}\r\n                        style={{\r\n                            width: '95%',\r\n                            height: '10%', \r\n                            backgroundColor: '#18a300',\r\n                            border: 'none',\r\n                            color: '#ffffff',\r\n                        }}\r\n                        >\r\n                            Restart\r\n                        </button>\r\n                    }\r\n                </div> \r\n            </GameOverContext.Provider>\r\n        </>\r\n    )\r\n}\r\n\r\nexport default React.memo(App);","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './components/App';\r\n\r\nconst rootNode = document.querySelector(\"#root\");\r\n\r\nReactDOM.render(\r\n    <App/>, rootNode\r\n);"],"sourceRoot":""}